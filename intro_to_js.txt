complete javascript notes



✅ 1. Hoisting in JavaScript
Definition:
Hoisting is JavaScript's default behavior of moving declarations (not initializations) 
to the top of the current scope (script or function).

ex:

console.log(x); // undefined
var x = 5;

greet();        // "Hello!"
function greet() {
  console.log("Hello!");
}

console.log(y); // ReferenceError: Cannot access 'y' before initialization
let y = 10;



✅ 2. Execution Context in JavaScript
Definition:Execution Context is the environment in which JavaScript code is evaluated and executed.
There are three types:(generally two)
1. Global Execution Context (GEC) – created when the file/script starts.
2. Function Execution Context (FEC) – created each time a function is called.
3. Eval Execution Context – for code inside eval() (not commonly used).

🔁 Execution Phases:
Every execution context goes through two phases:
1️⃣ Creation Phase(memory)

* Hoisting happens here.
* A memory space is created for variables and functions.
* Variables declared with var are set to undefined.
* Functions are fully stored.
* let and const go into TDZ (Temporal Dead Zone).
2️⃣ Execution Phase(code)

* Code is executed line-by-line.
* Variables are assigned values.
* Functions are invoked.




Feature	                Hoisted	        Initialized	             Access Before Declaration
var	                    ✅	              undefined	              ✅ (returns undefined)
let / const	            ✅	              ❌ (TDZ)	               ❌ (ReferenceError)
Function Decl.	        ✅	              ✅	                     ✅
Function Expr./Arrow	  ✅	              ❌ (as undefined)	     ❌ (TypeError if called)



📌 this in JavaScript
Definition:The this keyword refers to the object that is executing the current function.



Context |                       this Refers To
Global scope |                  Global object (window or global)
Regular function |              Global object (non-strict) or undefined
Object method |                 The object calling the method
Arrow function |                Lexical (parent) scope
Constructor function |          Newly created instance
call, apply, bind |             Explicitly defined object




--------------Shortest JavaScript Program-----------



The shortest valid JavaScript program is:


(Yes—an empty file.)

✅ Why is it valid?
JavaScript doesn’t require a main() function or any specific entry point.

An empty script is still valid and runs without any syntax errors.

The JavaScript engine simply creates the Global Execution Context, does nothing, and exits cleanly.

🔍 Explanation:
When this runs:

Global Execution Context is created.

No code → no memory allocation or execution.

Program ends without error.




-------Loosely Typed Language in JavaScript----------


What does loosely typed mean?
JavaScript is a loosely typed or dynamically typed language.
This means variables are not bound to a specific data type when declared.

Example:
javascript
Copy
Edit
let x = 10;      // x is a number
x = "hello";     // now x is a string
x = true;        // now x is a boolean
A single variable can hold different types of values at different times.
JavaScript determines the type of the variable at runtime.

Key Points:
Variables can hold any data type.

You do not need to specify the type of variable while declaring it.

Type checking happens during program execution.

JavaScript uses automatic type conversion when needed.

Example of Type Coercion:
console.log("5" + 1); // Outputs "51" (string concatenation)
console.log("5" - 1); // Outputs 4   (number subtraction)


JavaScript converts data types automatically depending on the operation, 
which can sometimes lead to unexpected results.



------------undefined and not defined-------------


These two terms look similar but mean very different things in JavaScript.
1. Undefined
  -A variable is declared but not assigned any value.
  -JavaScript automatically assigns undefined to it.
  -It also happens if a function does not return anything.


2. Not Defined
  -A variable is used without being declared at all.
  -JavaScript throws a ReferenceError.

In short
Undefined means: Variable exists, but no value yet.
Not defined means: Variable was never declared.


--------scope chain in JS--------


What is Scope?
Scope in JavaScript refers to the accessibility of variables—
where they can be used or referenced in the code.

-There are mainly three types of scope:
  1.Global Scope

  2.Local/Function Scope

  3.Block Scope (introduced in ES6 with let and const)


What is the Scope Chain?
The scope chain is the mechanism JavaScript uses to look for variables.
When you try to access a variable, JavaScript looks:

In the current scope.
If not found, it moves to the outer scope.
This continues up the chain until the variable is found or the global scope is reached.
If not found even there, it throws a ReferenceError.
This chain of nested scopes is called the scope chain.

In JavaScript, "lexical" is often used in terms like:

          -Lexical Scope

          -Lexical Environment

          -Lexical Context

They all relate to how scope is determined based on where code is written, not where it is executed.

Lexical Scope:
Lexical scope means that the scope of a variable is determined by its location in the source code.

Lexical Environment:
A Lexical Environment is an internal JavaScript concept.
Each time a function runs, a Lexical Environment is created, which contains:

        Local memory (variables, functions declared inside it)

        A reference to the outer Lexical Environment (where it was defined)
Keyword | Hoisted | Initialized at compile time? | Access before declaration
var | Yes | Yes (initialized with undefined) | Allowed (returns undefined)
let | Yes | No | Not allowed (TDZ error)
const | Yes | No | Not allowed (TDZ error)



--------hoisting in let and const keys------



Keyword | Hoisted |   Initialized at compile time? | Access before declaration
var |     Yes |       Yes (initialized with undefined) | Allowed (returns undefined)
let |     Yes |       No | Not allowed (TDZ error)
const |   Yes |       No | Not allowed (TDZ error)



let and const are hoisted but not initialized.

This creates a Temporal Dead Zone, where the variable exists but cannot be used.

Accessing the variable inside the TDZ throws a ReferenceError.

Always declare variables before using them to avoid TDZ issues.



-----------types of errors---------



1. Syntax Error
Occurs when the JavaScript code has incorrect syntax.
more declarations for same variable
Example:
if (x > 5 console.log("Hello"));
Here, the missing parenthesis causes a syntax error.

2. Reference Error
Happens when trying to access a variable that hasn’t been declared.
not defined
Example:
console.log(myVar);
If myVar is not declared anywhere, it throws a reference error.

3. Type Error
Occurs when a value is used in an inappropriate way.
after const keyword is used and declared with other value
Example:
null.toString();
You can’t call a method on null, so this will cause a type error.



--------------closures-------------



A closure is the combination of a function bundled together (enclosed) with 
references to its surrounding state (the lexical environment). 
In other words, a closure gives a function access to its outer scope. 
In JavaScript, closures are created every time a function is created, at function creation time.




