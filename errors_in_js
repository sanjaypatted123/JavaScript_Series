Letâ€™s dive deeper into all the potential errors that can occur when using fetch() in JavaScript, and 
explain why they happen, what they look like, and how to handle them.

ğŸ”´ 1. Invalid URL / Network Error
â“ What is it?
When the URL you're requesting is not reachable or misspelled, the browser can't connect to the server.

ğŸ”¥ Error Message:
TypeError: Failed to fetch
ğŸ§  Why?
The domain doesnâ€™t exist (e.g., https://api.example.com/data)

You're offline

Firewall or browser blocks the request

âœ… Solution:
Make sure the URL is real and working.

Check your network.

Try with a valid public API:


fetch('https://jsonplaceholder.typicode.com/posts')
ğŸ”´ 2. CORS Error (Cross-Origin Resource Sharing)
â“ What is it?
When a website tries to make a request to another domain (cross-origin), the server must explicitly allow it.

ğŸ”¥ Error Message (in browser console):

Access to fetch at 'https://someapi.com' from origin 'http://yourdomain.com' has been blocked by CORS policy
ğŸ§  Why?
The API server does not include CORS headers (like Access-Control-Allow-Origin)

The browser blocks the request for security

âœ… Solution:
Use APIs that support CORS

If testing, use a CORS proxy like:


fetch('https://cors-anywhere.herokuapp.com/https://example.com/api')
Or, configure your own server to allow CORS

ğŸ”´ 3. HTTP Status Errors (404, 500, etc.)
â“ What is it?
The server responds with an HTTP status code like 404 (Not Found) or 500 (Internal Server Error).

ğŸ”¥ Problem:
fetch() does not treat these as errors. So .then() runs, even if the request failed.


fetch('https://jsonplaceholder.typicode.com/unknown')
  .then(res => res.json()) // â† this still runs!
ğŸ§  Why?
fetch() only throws errors for network-level issues, not for HTTP status codes.

âœ… Solution:
Manually check response.ok:


fetch('https://jsonplaceholder.typicode.com/unknown')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .catch(error => console.error('Fetch failed:', error));
ğŸ”´ 4. Invalid JSON Format
â“ What is it?
If the server responds with something that's not valid JSON, calling response.json() will throw an error.

ğŸ”¥ Error Message:

SyntaxError: Unexpected token < in JSON at position 0
ğŸ§  Why?
The server returned HTML (e.g., an error page)

Or returned plain text, XML, or broken JSON

âœ… Solution:
Inspect the serverâ€™s response using response.text() first (for debugging)

Make sure the API returns Content-Type: application/json

Example:


fetch('https://example.com/api')
  .then(res => res.text()) // First inspect raw text
  .then(text => console.log(text));
ğŸ”´ 5. JavaScript Logic Errors
â“ What is it?
Even if the fetch itself works, your code logic may fail â€” for example, if you assume data always has a certain shape.

ğŸ”¥ Example:

.then(data => {
  console.log(data.name.toUpperCase()); // TypeError: Cannot read property 'toUpperCase' of undefined
});
ğŸ§  Why?
The API response structure is different from what you expect

âœ… Solution:
Always inspect and validate data before using it.


if (data && data.name) {
  console.log(data.name.toUpperCase());
}
ğŸ”´ 6. Unhandled Promise Rejection (if .catch() is missing)
â“ What is it?
If you donâ€™t use .catch() (or try/catch in async/await), the error will go uncaught.

ğŸ”¥ Error Message:
In newer browsers:


Uncaught (in promise) TypeError: Failed to fetch
âœ… Solution:
Always handle errors:


fetch(url)
  .then(...)
  .catch(err => console.error('Fetch failed:', err));
Or using async/await:


try {
  const response = await fetch(url);
  const data = await response.json();
} catch (err) {
  console.error('Error:', err);
}
